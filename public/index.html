<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
  <title>goto-assistant</title>
  <link rel="stylesheet" href="/style.css">
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
</head>
<body>
  <div class="chat-layout">
    <div class="sidebar">
      <div class="sidebar-header">
        <h2>Conversations</h2>
        <button class="btn-icon" id="newChatBtn" title="New chat">+</button>
      </div>
      <div class="conversation-list" id="conversationList"></div>
    </div>
    <div class="sidebar-overlay" id="sidebarOverlay"></div>

    <div class="chat-main">
      <div class="chat-header">
        <button class="hamburger-btn" id="hamburgerBtn">&#9776;</button>
        <img src="/logo.svg" alt="goto" class="header-logo">
        <h2 id="chatTitle">New Conversation</h2>
        <button class="settings-btn" id="settingsBtn" title="Settings">&#9881;</button>
      </div>

      <div class="messages" id="messages"></div>

      <div class="input-area">
        <div class="file-preview" id="filePreview"></div>
        <div class="input-row">
          <button class="file-upload-btn" id="fileUploadBtn" title="Attach image">&#128206;</button>
          <input type="file" id="fileInput" accept="image/jpeg,image/png,image/gif,image/webp" multiple hidden>
          <textarea id="input" rows="1" placeholder="Send a message..." autofocus></textarea>
          <button class="btn btn-primary" id="sendBtn">Send</button>
        </div>
      </div>
    </div>
  </div>

  <script>
    let ws = null;
    let currentConversationId = null;
    let currentAssistantEl = null;
    let pendingFiles = []; // Files selected but not yet sent

    function connectWs() {
      const protocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
      ws = new WebSocket(`${protocol}//${location.host}/ws`);
      ws.onmessage = (e) => {
        const msg = JSON.parse(e.data);
        if (msg.type === 'chunk') {
          if (!currentAssistantEl) {
            currentAssistantEl = addMessage('assistant', '');
            currentAssistantEl._raw = '';
          }
          currentAssistantEl._raw += msg.text;
          // Update only the text div (last child)
          const textDiv = currentAssistantEl.lastElementChild;
          if (textDiv) textDiv.innerHTML = marked.parse(currentAssistantEl._raw);
        } else if (msg.type === 'done') {
          currentConversationId = msg.conversationId;
          currentAssistantEl = null;
          removeTypingIndicator();
          loadConversations();
        } else if (msg.type === 'error') {
          removeTypingIndicator();
          currentAssistantEl = null;
          addMessage('assistant', 'Error: ' + msg.text);
        }
      };
      ws.onclose = () => { setTimeout(connectWs, 2000); };
    }

    function parseContent(content) {
      try {
        const parsed = JSON.parse(content);
        if (parsed && typeof parsed.text === 'string') return parsed;
      } catch {}
      return { text: content };
    }

    function addMessage(role, content, extraAttachments) {
      const el = document.createElement('div');
      el.className = 'message ' + role;
      const parsed = parseContent(content);
      const attachments = extraAttachments || parsed.attachments;

      // Render attachment images
      if (attachments && attachments.length > 0) {
        const strip = document.createElement('div');
        strip.className = 'message-attachments';
        for (const att of attachments) {
          const img = document.createElement('img');
          img.className = 'attachment-img';
          img.src = `/api/uploads/${att.fileId}`;
          img.alt = att.filename;
          img.loading = 'lazy';
          strip.appendChild(img);
        }
        el.appendChild(strip);
      }

      const textContent = parsed.text;
      const textEl = document.createElement('div');
      if (role === 'assistant' && textContent) {
        textEl.innerHTML = marked.parse(textContent);
      } else if (textContent) {
        textEl.textContent = textContent;
      }
      el.appendChild(textEl);
      document.getElementById('messages').appendChild(el);
      el.scrollIntoView({ behavior: 'smooth' });
      return el;
    }

    function addTypingIndicator() {
      const el = document.createElement('div');
      el.className = 'typing-indicator';
      el.id = 'typing';
      el.textContent = 'Thinking...';
      document.getElementById('messages').appendChild(el);
      el.scrollIntoView({ behavior: 'smooth' });
    }

    function removeTypingIndicator() {
      const el = document.getElementById('typing');
      if (el) el.remove();
    }

    async function sendMessage() {
      const input = document.getElementById('input');
      const text = input.value.trim();
      if ((!text && pendingFiles.length === 0) || !ws || ws.readyState !== WebSocket.OPEN) return;

      // Upload pending files
      let attachments = [];
      if (pendingFiles.length > 0) {
        for (const file of pendingFiles) {
          const form = new FormData();
          form.append('file', file);
          try {
            const res = await fetch('/api/upload', { method: 'POST', body: form });
            if (res.ok) {
              const data = await res.json();
              attachments.push({ fileId: data.fileId, filename: data.filename, mimeType: data.mimeType });
            }
          } catch {}
        }
        pendingFiles = [];
        renderFilePreview();
      }

      addMessage('user', text || '(image)', attachments.length > 0 ? attachments : undefined);
      addTypingIndicator();
      const payload = {
        type: 'message',
        text: text || 'Describe this image.',
        conversationId: currentConversationId,
      };
      if (attachments.length > 0) payload.attachments = attachments;
      ws.send(JSON.stringify(payload));
      input.value = '';
      input.style.height = 'auto';
    }

    // Auto-resize textarea
    const input = document.getElementById('input');
    input.addEventListener('input', () => {
      input.style.height = 'auto';
      input.style.height = Math.min(input.scrollHeight, 200) + 'px';
    });
    input.addEventListener('keydown', (e) => {
      if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        sendMessage();
      }
    });

    document.getElementById('sendBtn').addEventListener('click', sendMessage);

    // File upload handling
    document.getElementById('fileUploadBtn').addEventListener('click', () => {
      document.getElementById('fileInput').click();
    });
    document.getElementById('fileInput').addEventListener('change', (e) => {
      for (const file of e.target.files) {
        pendingFiles.push(file);
      }
      e.target.value = '';
      renderFilePreview();
    });

    function renderFilePreview() {
      const preview = document.getElementById('filePreview');
      preview.innerHTML = '';
      if (pendingFiles.length === 0) { preview.style.display = 'none'; return; }
      preview.style.display = 'flex';
      pendingFiles.forEach((file, i) => {
        const item = document.createElement('div');
        item.className = 'file-preview-item';
        const img = document.createElement('img');
        img.src = URL.createObjectURL(file);
        img.onload = () => URL.revokeObjectURL(img.src);
        item.appendChild(img);
        const removeBtn = document.createElement('button');
        removeBtn.className = 'file-preview-remove';
        removeBtn.textContent = '×';
        removeBtn.addEventListener('click', () => {
          pendingFiles.splice(i, 1);
          renderFilePreview();
        });
        item.appendChild(removeBtn);
        preview.appendChild(item);
      });
    }

    // New chat
    document.getElementById('newChatBtn').addEventListener('click', () => {
      currentConversationId = null;
      currentAssistantEl = null;
      document.getElementById('messages').innerHTML = '';
      document.getElementById('chatTitle').textContent = 'New Conversation';
      document.querySelectorAll('.conversation-item').forEach(el => el.classList.remove('active'));
      closeSidebar();
    });

    // Settings
    document.getElementById('settingsBtn').addEventListener('click', () => {
      window.location.href = '/setup.html';
    });

    // Load conversations
    async function loadConversations() {
      try {
        const res = await fetch('/api/conversations');
        const data = await res.json();
        const list = document.getElementById('conversationList');
        list.innerHTML = '';
        data.conversations.forEach(c => {
          const el = document.createElement('div');
          el.className = 'conversation-item' + (c.id === currentConversationId ? ' active' : '');
          const date = new Date(c.created_at).toLocaleDateString();
          const displayTitle = c.title || `${c.provider} — ${date}`;
          el.title = displayTitle;

          const titleSpan = document.createElement('span');
          titleSpan.className = 'conv-title';
          titleSpan.textContent = displayTitle;
          el.appendChild(titleSpan);

          const deleteBtn = document.createElement('button');
          deleteBtn.className = 'btn-icon delete-btn';
          deleteBtn.textContent = '×';
          deleteBtn.title = 'Delete conversation';
          deleteBtn.addEventListener('click', async (e) => {
            e.stopPropagation();
            if (!confirm('Delete this conversation?')) return;
            await fetch(`/api/conversations/${c.id}`, { method: 'DELETE' });
            if (currentConversationId === c.id) {
              currentConversationId = null;
              currentAssistantEl = null;
              document.getElementById('messages').innerHTML = '';
              document.getElementById('chatTitle').textContent = 'New Conversation';
            }
            loadConversations();
          });
          el.appendChild(deleteBtn);

          titleSpan.addEventListener('click', async () => {
            currentConversationId = c.id;
            document.getElementById('messages').innerHTML = '';
            document.getElementById('chatTitle').textContent = displayTitle;
            closeSidebar();
            document.querySelectorAll('.conversation-item').forEach(e => e.classList.remove('active'));
            el.classList.add('active');
            try {
              const msgRes = await fetch(`/api/conversations/${c.id}/messages`);
              const msgData = await msgRes.json();
              msgData.messages.forEach(m => addMessage(m.role, m.content));
            } catch {}
          });
          list.appendChild(el);
        });
      } catch {}
    }

    // Sidebar toggle (mobile)
    function toggleSidebar() {
      document.querySelector('.sidebar').classList.toggle('open');
      document.getElementById('sidebarOverlay').classList.toggle('open');
    }
    function closeSidebar() {
      document.querySelector('.sidebar').classList.remove('open');
      document.getElementById('sidebarOverlay').classList.remove('open');
    }
    document.getElementById('hamburgerBtn').addEventListener('click', toggleSidebar);
    document.getElementById('sidebarOverlay').addEventListener('click', closeSidebar);

    // Swipe gesture: right from left edge opens sidebar, left closes
    let touchStartX = 0;
    let touchStartY = 0;
    document.addEventListener('touchstart', (e) => {
      touchStartX = e.touches[0].clientX;
      touchStartY = e.touches[0].clientY;
    }, { passive: true });
    document.addEventListener('touchend', (e) => {
      const dx = e.changedTouches[0].clientX - touchStartX;
      const dy = Math.abs(e.changedTouches[0].clientY - touchStartY);
      if (dy > Math.abs(dx)) return; // vertical swipe
      if (dx > 80 && touchStartX < 30) toggleSidebar();
      else if (dx < -80 && document.querySelector('.sidebar').classList.contains('open')) closeSidebar();
    }, { passive: true });

    connectWs();
    loadConversations();
  </script>
</body>
</html>
