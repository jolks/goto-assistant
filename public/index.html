<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
  <meta name="color-scheme" content="light dark">
  <title>goto-assistant</title>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@picocss/pico@2.1.1/css/pico.min.css">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Bricolage+Grotesque:opsz,wght@12..96,200..800&family=Instrument+Serif:ital@0;1&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="/style.css">
  <script src="https://cdn.jsdelivr.net/npm/marked@15.0.12/marked.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/dompurify@3.3.1/dist/purify.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/cronstrue@2.61.0/dist/cronstrue.min.js"></script>
  <script src="/chat-core.js"></script>
  <script src="/task-chat.js"></script>
</head>
<body>
  <div class="chat-layout">
    <div class="sidebar">
      <div class="sidebar-tabs">
        <button class="sidebar-tab active" data-tab="conversations" onclick="switchTab('conversations')">Conversations</button>
        <button class="sidebar-tab" data-tab="tasks" onclick="switchTab('tasks')">Tasks</button>
      </div>
      <div class="sidebar-panel active" id="panelConversations">
        <div class="sidebar-panel-header">
          <button class="btn-icon" id="newChatBtn" title="New chat">+</button>
        </div>
        <div class="conversation-list" id="conversationList"></div>
      </div>
      <div class="sidebar-panel" id="panelTasks">
        <div class="sidebar-panel-header">
          <button class="btn-icon" id="newTaskBtn" title="Create task">+</button>
        </div>
        <div class="task-list" id="taskList"></div>
      </div>
    </div>
    <div class="sidebar-overlay" id="sidebarOverlay"></div>

    <div class="chat-main">
      <div class="chat-header">
        <button class="hamburger-btn" id="hamburgerBtn">&#9776;</button>
        <h2 id="chatTitle">New Conversation</h2>
        <button class="settings-btn" id="settingsBtn" title="Settings">&#9881;</button>
      </div>

      <div class="messages" id="messages">
        <div class="empty-state" id="emptyState">
          <img src="/logo.svg" alt="goto-assistant" class="empty-state-logo">
          <p class="empty-state-text">How can I help you today?</p>
        </div>
      </div>

      <div class="input-area">
        <div class="file-preview" id="filePreview"></div>
        <div class="input-row">
          <button class="file-upload-btn" id="fileUploadBtn" title="Attach image">&#128206;</button>
          <input type="file" id="fileInput" accept="image/jpeg,image/png,image/gif,image/webp" multiple hidden>
          <textarea id="input" rows="1" placeholder="Send a message..." autofocus></textarea>
          <button class="btn btn-primary" id="sendBtn">Send</button>
        </div>
      </div>
    </div>

    <!-- Task Detail / Create View -->
    <div class="task-detail" id="taskDetail" style="display:none">
      <div class="task-detail-header">
        <button class="task-back-btn" id="taskBackBtn" title="Back to tasks">&larr;</button>
        <h2 id="taskDetailTitle">Task</h2>
        <div class="task-detail-actions" id="taskDetailActions">
          <button class="btn-icon" id="taskRunBtn" title="Run now">&#9654;</button>
          <button class="btn-icon" id="taskToggleBtn" title="Enable/Disable"></button>
          <button class="btn-icon" id="taskDeleteBtn" title="Delete">&#128465;</button>
        </div>
        <button class="task-chat-toggle" id="taskChatToggle" title="Chat">&#128172;</button>
      </div>
      <div class="task-detail-body">
        <div class="task-info" id="taskInfo">
          <div class="task-meta" id="taskMeta"></div>
          <div class="task-content" id="taskContent"></div>
          <div class="task-results" id="taskResults"></div>
        </div>
        <div class="task-create-empty" id="taskCreateEmpty">
          <p>Describe the task you'd like to create</p>
          <button class="task-create-empty-btn" id="taskCreateOpenChat">Start chatting &rarr;</button>
        </div>
        <div class="task-chat-panel mobile-slide-overlay" id="taskChatPanel">
          <div class="task-chat-header">
            <h3>Task Chat</h3>
            <button class="task-chat-close" id="taskChatClose">&times;</button>
          </div>
          <div class="task-chat-messages" id="taskChatMessages"></div>
          <div class="task-chat-input">
            <div class="setup-chat-input-row">
              <textarea id="taskChatInput" rows="1" placeholder="Ask AI to modify this task..."></textarea>
              <button id="taskChatSendBtn">Send</button>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <script>
    let ws = null;
    let currentConversationId = null;
    let currentAssistantEl = null;
    let pendingFiles = []; // Files selected but not yet sent

    function connectWs() {
      chatCreateWs({
        onMessage: function (e) {
          const msg = JSON.parse(e.data);
          if (msg.type === 'chunk') {
            if (!currentAssistantEl) {
              currentAssistantEl = addMessage('assistant', '');
              currentAssistantEl._raw = '';
            }
            currentAssistantEl._raw += msg.text;
            const textDiv = currentAssistantEl.lastElementChild;
            if (textDiv) textDiv.innerHTML = DOMPurify.sanitize(marked.parse(currentAssistantEl._raw));
          } else if (msg.type === 'done') {
            currentConversationId = msg.conversationId;
            currentAssistantEl = null;
            removeTypingIndicator();
            loadConversations();
          } else if (msg.type === 'error') {
            removeTypingIndicator();
            currentAssistantEl = null;
            addMessage('assistant', 'Error: ' + msg.text);
          }
        },
        onOpen: function (newWs) {
          ws = newWs;
        },
        onClose: function (closedWs) {
          if (ws === closedWs) ws = null;
        },
        shouldReconnect: function () { return true; },
      });
    }

    function parseContent(content) {
      try {
        const parsed = JSON.parse(content);
        if (parsed && typeof parsed.text === 'string') return parsed;
      } catch {}
      return { text: content };
    }

    function hideEmptyState() {
      const es = document.getElementById('emptyState');
      if (es) es.style.display = 'none';
    }
    function clearMessages() {
      const m = document.getElementById('messages');
      m.innerHTML = '<div class="empty-state" id="emptyState"><img src="/logo.svg" alt="goto-assistant" class="empty-state-logo"><p class="empty-state-text">How can I help you today?</p></div>';
    }

    function addMessage(role, content, extraAttachments) {
      hideEmptyState();
      const el = document.createElement('div');
      el.className = 'message ' + role;
      const parsed = parseContent(content);
      const attachments = extraAttachments || parsed.attachments;

      // Render attachment images
      if (attachments && attachments.length > 0) {
        const strip = document.createElement('div');
        strip.className = 'message-attachments';
        for (const att of attachments) {
          const img = document.createElement('img');
          img.className = 'attachment-img';
          img.src = `/api/uploads/${att.fileId}`;
          img.alt = att.filename;
          img.loading = 'lazy';
          strip.appendChild(img);
        }
        el.appendChild(strip);
      }

      const textContent = parsed.text;
      const textEl = document.createElement('div');
      if (role === 'assistant' && textContent) {
        textEl.innerHTML = DOMPurify.sanitize(marked.parse(textContent));
      } else if (textContent) {
        textEl.textContent = textContent;
      }
      el.appendChild(textEl);
      document.getElementById('messages').appendChild(el);
      el.scrollIntoView({ behavior: 'smooth' });
      return el;
    }

    function addTypingIndicator() {
      chatAddTypingIndicator('messages', 'typing');
    }

    function removeTypingIndicator() {
      chatRemoveTypingIndicator('typing');
    }

    async function sendMessage() {
      const input = document.getElementById('input');
      const text = input.value.trim();
      if ((!text && pendingFiles.length === 0) || !ws || ws.readyState !== WebSocket.OPEN) return;

      // Upload pending files
      let attachments = [];
      if (pendingFiles.length > 0) {
        for (const file of pendingFiles) {
          const form = new FormData();
          form.append('file', file);
          try {
            const res = await fetch('/api/upload', { method: 'POST', body: form });
            if (res.ok) {
              const data = await res.json();
              attachments.push({ fileId: data.fileId, filename: data.filename, mimeType: data.mimeType });
            }
          } catch {}
        }
        pendingFiles = [];
        renderFilePreview();
      }

      addMessage('user', text || '(image)', attachments.length > 0 ? attachments : undefined);
      addTypingIndicator();
      const payload = {
        type: 'message',
        text: text || 'Describe this image.',
        conversationId: currentConversationId,
      };
      if (attachments.length > 0) payload.attachments = attachments;
      ws.send(JSON.stringify(payload));
      input.value = '';
      input.style.height = 'auto';
    }

    // Auto-resize textarea
    const input = document.getElementById('input');
    input.addEventListener('input', () => {
      input.style.height = 'auto';
      input.style.height = Math.min(input.scrollHeight, 200) + 'px';
    });
    input.addEventListener('keydown', (e) => {
      if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        sendMessage();
      }
    });

    document.getElementById('sendBtn').addEventListener('click', sendMessage);

    // File upload handling
    document.getElementById('fileUploadBtn').addEventListener('click', () => {
      document.getElementById('fileInput').click();
    });
    document.getElementById('fileInput').addEventListener('change', (e) => {
      for (const file of e.target.files) {
        pendingFiles.push(file);
      }
      e.target.value = '';
      renderFilePreview();
    });

    function renderFilePreview() {
      const preview = document.getElementById('filePreview');
      preview.innerHTML = '';
      if (pendingFiles.length === 0) { preview.style.display = 'none'; return; }
      preview.style.display = 'flex';
      pendingFiles.forEach((file, i) => {
        const item = document.createElement('div');
        item.className = 'file-preview-item';
        const img = document.createElement('img');
        img.src = URL.createObjectURL(file);
        img.onload = () => URL.revokeObjectURL(img.src);
        item.appendChild(img);
        const removeBtn = document.createElement('button');
        removeBtn.className = 'file-preview-remove';
        removeBtn.textContent = '×';
        removeBtn.addEventListener('click', () => {
          pendingFiles.splice(i, 1);
          renderFilePreview();
        });
        item.appendChild(removeBtn);
        preview.appendChild(item);
      });
    }

    // New chat
    document.getElementById('newChatBtn').addEventListener('click', () => {
      currentConversationId = null;
      currentAssistantEl = null;
      showChatMain();
      clearMessages();
      document.getElementById('chatTitle').textContent = 'New Conversation';
      document.querySelectorAll('.conversation-item').forEach(el => el.classList.remove('active'));
      closeSidebar();
    });

    // Settings
    document.getElementById('settingsBtn').addEventListener('click', () => {
      window.location.href = '/setup.html';
    });

    // Load conversations
    async function loadConversations() {
      try {
        const res = await fetch('/api/conversations');
        const data = await res.json();
        const list = document.getElementById('conversationList');
        list.innerHTML = '';
        data.conversations.forEach(c => {
          const el = document.createElement('div');
          el.className = 'conversation-item' + (c.id === currentConversationId ? ' active' : '');
          const date = new Date(c.created_at).toLocaleDateString();
          const displayTitle = c.title || `${c.provider} — ${date}`;
          el.title = displayTitle;

          const titleSpan = document.createElement('span');
          titleSpan.className = 'conv-title';
          titleSpan.textContent = displayTitle;
          el.appendChild(titleSpan);

          const deleteBtn = document.createElement('button');
          deleteBtn.className = 'btn-icon delete-btn';
          deleteBtn.textContent = '×';
          deleteBtn.title = 'Delete conversation';
          deleteBtn.addEventListener('click', async (e) => {
            e.stopPropagation();
            if (!confirm('Delete this conversation?')) return;
            await fetch(`/api/conversations/${c.id}`, { method: 'DELETE' });
            if (currentConversationId === c.id) {
              currentConversationId = null;
              currentAssistantEl = null;
              clearMessages();
              document.getElementById('chatTitle').textContent = 'New Conversation';
            }
            loadConversations();
          });
          el.appendChild(deleteBtn);

          titleSpan.addEventListener('click', async () => {
            currentConversationId = c.id;
            showChatMain();
            document.getElementById('messages').innerHTML = '';
            hideEmptyState();
            document.getElementById('chatTitle').textContent = displayTitle;
            closeSidebar();
            document.querySelectorAll('.conversation-item').forEach(e => e.classList.remove('active'));
            el.classList.add('active');
            try {
              const msgRes = await fetch(`/api/conversations/${c.id}/messages`);
              const msgData = await msgRes.json();
              msgData.messages.forEach(m => addMessage(m.role, m.content));
            } catch {}
          });
          list.appendChild(el);
        });
      } catch {}
    }

    // Sidebar toggle (mobile)
    function toggleSidebar() {
      document.querySelector('.sidebar').classList.toggle('open');
      document.getElementById('sidebarOverlay').classList.toggle('open');
    }
    function closeSidebar() {
      document.querySelector('.sidebar').classList.remove('open');
      document.getElementById('sidebarOverlay').classList.remove('open');
    }
    document.getElementById('hamburgerBtn').addEventListener('click', toggleSidebar);
    document.getElementById('sidebarOverlay').addEventListener('click', closeSidebar);

    // Swipe gesture: right from left edge opens sidebar, left closes
    let touchStartX = 0;
    let touchStartY = 0;
    document.addEventListener('touchstart', (e) => {
      touchStartX = e.touches[0].clientX;
      touchStartY = e.touches[0].clientY;
    }, { passive: true });
    document.addEventListener('touchend', (e) => {
      const dx = e.changedTouches[0].clientX - touchStartX;
      const dy = Math.abs(e.changedTouches[0].clientY - touchStartY);
      if (dy > Math.abs(dx)) return; // vertical swipe
      if (dx > 80 && touchStartX < 30) toggleSidebar();
      else if (dx < -80 && document.querySelector('.sidebar').classList.contains('open')) closeSidebar();
    }, { passive: true });

    // --- Task Management ---
    let currentTaskId = null;
    let currentTab = 'conversations';

    function escapeHtml(str) {
      const d = document.createElement('div');
      d.textContent = str;
      return d.innerHTML;
    }

    function formatDuration(startTime, endTime) {
      if (!startTime || !endTime) return '';
      const ms = new Date(endTime) - new Date(startTime);
      if (ms < 1000) return ms + 'ms';
      const secs = Math.round(ms / 1000);
      if (secs < 60) return secs + 's';
      const mins = Math.floor(secs / 60);
      const remSecs = secs % 60;
      if (mins < 60) return mins + 'm ' + remSecs + 's';
      const hrs = Math.floor(mins / 60);
      return hrs + 'h ' + (mins % 60) + 'm';
    }

    function switchTab(tab) {
      currentTab = tab;
      document.querySelectorAll('.sidebar-tab').forEach(t => {
        t.classList.toggle('active', t.dataset.tab === tab);
      });
      document.getElementById('panelConversations').classList.toggle('active', tab === 'conversations');
      document.getElementById('panelTasks').classList.toggle('active', tab === 'tasks');
      if (tab === 'tasks') loadTasks();
    }

    function showChatMain() {
      document.querySelector('.chat-main').style.display = '';
      document.getElementById('taskDetail').style.display = 'none';
      document.getElementById('taskChatPanel').classList.remove('open');
      disconnectTaskChat();
    }

    function showTaskDetail() {
      document.querySelector('.chat-main').style.display = 'none';
      document.getElementById('taskDetail').style.display = '';
    }

    async function loadTasks() {
      try {
        const res = await fetch('/api/tasks');
        const data = await res.json();
        const tasks = Array.isArray(data) ? data : (data.tasks || []);
        renderTaskList(tasks);
      } catch {
        renderTaskList([]);
      }
    }

    function renderTaskList(tasks) {
      const list = document.getElementById('taskList');
      list.innerHTML = '';
      if (tasks.length === 0) {
        list.innerHTML = '<div class="task-list-empty">No tasks yet</div>';
        return;
      }
      tasks.forEach(t => {
        const el = document.createElement('div');
        el.className = 'task-item' + (t.id === currentTaskId ? ' active' : '');
        el.dataset.taskId = t.id;
        const dot = document.createElement('span');
        dot.className = 'task-status-dot' + (t.enabled ? ' enabled' : '');
        dot.title = t.enabled ? 'Enabled' : 'Disabled';
        el.appendChild(dot);
        const name = document.createElement('span');
        name.className = 'task-item-name';
        name.textContent = t.name || t.id;
        el.appendChild(name);
        const badge = document.createElement('span');
        badge.className = 'task-type-badge';
        badge.textContent = t.type === 'AI' ? 'AI' : 'CMD';
        el.appendChild(badge);
        el.addEventListener('click', () => openTask(t.id));
        list.appendChild(el);
      });
    }

    async function openTask(taskId) {
      var isSameTask = (currentTaskId === taskId) && taskChatState.active;
      currentTaskId = taskId;
      closeSidebar();
      // Highlight in list
      document.querySelectorAll('.task-item').forEach(e => {
        e.classList.toggle('active', e.dataset.taskId === taskId);
      });

      try {
        const [taskRes, resultsRes] = await Promise.all([
          fetch(`/api/tasks/${taskId}`),
          fetch(`/api/tasks/${taskId}/results?limit=5`),
        ]);
        const task = await taskRes.json();
        let results = null;
        try { results = await resultsRes.json(); } catch {}

        renderTaskDetail(task);
        renderTaskResult(results);

        // Init task chat with context (only reset if switching tasks)
        const context = JSON.stringify(task, null, 2);
        showTaskDetail();
        if (!isSameTask) {
          initTaskChat(context);
        } else {
          taskChatState.taskContext = context;
        }

        // Deliver any pending run result queued while viewing another task
        var pending = consumePendingResult(taskId);
        if (pending) {
          taskChatAddMessage('assistant', pending);
        }
      } catch (err) {
        showTaskDetail();
        document.getElementById('taskDetailTitle').textContent = 'Error';
        document.getElementById('taskMeta').innerHTML = '<p>Failed to load task.</p>';
      }
    }

    function renderTaskDetail(task) {
      document.getElementById('taskDetailTitle').textContent = task.name || task.id;
      document.getElementById('taskDetailActions').style.display = '';
      document.getElementById('taskInfo').style.display = '';
      document.querySelector('.task-detail-body').classList.remove('create-mode');

      // Meta
      const meta = document.getElementById('taskMeta');
      const humanSchedule = task.schedule ? cronToHuman(task.schedule) : null;
      meta.innerHTML = `
        <div class="task-meta-row"><span class="task-meta-label">ID</span><span class="task-meta-value">${escapeHtml(task.id || '')}</span></div>
        <div class="task-meta-row"><span class="task-meta-label">Type</span><span class="task-meta-value"><span class="task-type-badge">${task.type === 'AI' ? 'AI' : 'CMD'}</span></span></div>
        <div class="task-meta-row"><span class="task-meta-label">Status</span><span class="task-meta-value">${task.enabled ? '<span class="task-enabled-badge">Enabled</span>' : '<span class="task-disabled-badge">Disabled</span>'}</span></div>
        ${task.schedule ? `<div class="task-meta-row"><span class="task-meta-label">Schedule</span><span class="task-meta-value">${humanSchedule ? `<span class="task-schedule-human">${escapeHtml(humanSchedule)}</span> <code class="task-schedule-raw">${escapeHtml(task.schedule)}</code>` : `<code>${escapeHtml(task.schedule)}</code>`}</span></div>` : ''}
      `;

      // Content (prompt or command)
      const content = document.getElementById('taskContent');
      if (task.prompt) {
        content.innerHTML = `<div class="task-content-label">Prompt</div><pre class="task-content-pre">${escapeHtml(task.prompt)}</pre>`;
      } else if (task.command) {
        content.innerHTML = `<div class="task-content-label">Command</div><pre class="task-content-pre">${escapeHtml(task.command)}</pre>`;
      } else {
        content.innerHTML = '';
      }

      // Wire action buttons
      const runBtn = document.getElementById('taskRunBtn');
      const toggleBtn = document.getElementById('taskToggleBtn');
      const deleteBtn = document.getElementById('taskDeleteBtn');

      toggleBtn.textContent = task.enabled ? '\u25CF' : '\u25CB';
      toggleBtn.title = task.enabled ? 'Disable' : 'Enable';
      toggleBtn.style.color = task.enabled ? '#22c55e' : '';

      if (!task.enabled) {
        runBtn.style.display = 'none';
      } else if (isTaskRunning(task.id)) {
        runBtn.style.display = '';
        runBtn.disabled = true;
        runBtn.innerHTML = '&#9696;';
        runBtn.classList.add('task-running');
      } else {
        runBtn.style.display = '';
        runBtn.disabled = false;
        runBtn.innerHTML = '&#9654;';
        runBtn.classList.remove('task-running');
      }

      runBtn.onclick = () => {
        runTask(task.id, runBtn, renderTaskResult, formatDuration, () => currentTaskId);
      };

      toggleBtn.onclick = async () => {
        const endpoint = task.enabled ? 'disable' : 'enable';
        try {
          await fetch(`/api/tasks/${task.id}/${endpoint}`, { method: 'POST' });
          openTask(task.id);
          loadTasks();
        } catch {
          taskChatAddMessage('assistant', `Failed to ${endpoint} task. Please try again.`);
        }
      };

      deleteBtn.onclick = async () => {
        if (!confirm('Delete this task?')) return;
        try {
          await fetch(`/api/tasks/${task.id}`, { method: 'DELETE' });
          currentTaskId = null;
          showChatMain();
          loadTasks();
        } catch {
          taskChatAddMessage('assistant', 'Failed to delete task. Please try again.');
        }
      };
    }

    function renderTaskResult(resultData) {
      const container = document.getElementById('taskResults');
      if (!resultData || (Array.isArray(resultData) && resultData.length === 0)) {
        container.innerHTML = '<div class="task-content-label">Results</div><p class="task-no-results">No execution results yet.</p>';
        return;
      }
      const results = Array.isArray(resultData) ? resultData : [resultData];
      let html = '<div class="task-content-label">Recent Results</div>';
      results.forEach(r => {
        const time = r.start_time ? new Date(r.start_time).toLocaleString() : (r.timestamp ? new Date(r.timestamp).toLocaleString() : 'Unknown time');
        const isError = (r.exit_code !== 0 && r.exit_code !== undefined) || r.error != null;
        const status = isError ? 'error' : 'success';
        const output = r.output || r.error || r.result || '(no output)';
        const duration = formatDuration(r.start_time, r.end_time);
        const outputText = typeof output === 'string' ? output : JSON.stringify(output, null, 2);
        const renderedOutput = (typeof marked !== 'undefined' && marked.parse && typeof DOMPurify !== 'undefined')
          ? DOMPurify.sanitize(marked.parse(outputText))
          : escapeHtml(outputText);
        html += `<div class="task-result-item">
          <div class="task-result-header"><span class="task-result-time">${escapeHtml(time)}</span><div class="task-result-header-right">${duration ? '<span class="task-result-duration">' + escapeHtml(duration) + '</span>' : ''}<span class="task-result-status ${status}">${isError ? 'Failed' : 'OK'}</span></div></div>
          <div class="task-result-output">${renderedOutput}</div>
        </div>`;
      });
      container.innerHTML = html;
    }

    function openTaskCreate() {
      currentTaskId = null;
      closeSidebar();
      document.querySelectorAll('.task-item').forEach(e => e.classList.remove('active'));
      document.getElementById('taskDetailTitle').textContent = 'Create Task';
      document.getElementById('taskDetailActions').style.display = 'none';
      document.getElementById('taskInfo').style.display = 'none';
      document.querySelector('.task-detail-body').classList.add('create-mode');
      showTaskDetail();
      initTaskChat(null);
      // Auto-open chat overlay on mobile
      if (window.matchMedia('(max-width: 768px)').matches) {
        document.getElementById('taskChatPanel').classList.add('open');
      }
    }

    // On task chat done, refresh task info without clearing chat messages
    window.onTaskChatDone = async function () {
      if (currentTaskId) {
        try {
          const [taskRes, resultsRes] = await Promise.all([
            fetch(`/api/tasks/${currentTaskId}`),
            fetch(`/api/tasks/${currentTaskId}/results?limit=5`),
          ]);
          const task = await taskRes.json();
          let results = null;
          try { results = await resultsRes.json(); } catch {}
          renderTaskDetail(task);
          renderTaskResult(results);
          // Update chat context for subsequent messages
          taskChatState.taskContext = JSON.stringify(task, null, 2);
        } catch {}
      }
      loadTasks();
    };

    // Back button
    document.getElementById('taskBackBtn').addEventListener('click', () => {
      currentTaskId = null;
      showChatMain();
      document.querySelectorAll('.task-item').forEach(e => e.classList.remove('active'));
    });

    // New task button
    document.getElementById('newTaskBtn').addEventListener('click', openTaskCreate);

    // Task chat input handlers
    document.getElementById('taskChatSendBtn').addEventListener('click', () => {
      const input = document.getElementById('taskChatInput');
      const text = input.value.trim();
      if (!text) return;
      input.value = '';
      sendTaskChatMessage(text);
    });
    document.getElementById('taskChatInput').addEventListener('keydown', (e) => {
      if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        const input = document.getElementById('taskChatInput');
        const text = input.value.trim();
        if (!text) return;
        input.value = '';
        sendTaskChatMessage(text);
      }
    });

    // Mobile task chat overlay toggle
    document.getElementById('taskChatToggle').addEventListener('click', () => {
      document.getElementById('taskChatPanel').classList.add('open');
    });
    document.getElementById('taskChatClose').addEventListener('click', () => {
      document.getElementById('taskChatPanel').classList.remove('open');
    });
    document.getElementById('taskCreateOpenChat').addEventListener('click', () => {
      document.getElementById('taskChatPanel').classList.add('open');
    });

    connectWs();
    loadConversations();
  </script>
</body>
</html>
